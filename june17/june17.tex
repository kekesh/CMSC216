\section{Monday, June 17, 2019}

\subsection{Exit Codes} 
An \vocab{exit code} is a value that is returned to the \vocab{shell}, which is responsible for reading and executing your code. By convention, when everything goes well, we return $0$ (as we have been doing in all of our programs). 

The header file \verb!stdlib.h! contains a lot of preprocessor directives, which represent exit codes. For example, \verb!EXIT_SUCCESS! and \verb!EXIT_FAILURE! can be used when the program successfully executes or unsuccessfully executes (these would be used instead of having a line that says \verb!return 0!). It turns out that \verb!EXIT_SUCCESS! is actually a preprocessor directive for $0$. 


In order to use an exit code, we use the built-in \verb!void exit(int status)! function. So, for example, we could replace \verb!return 0! in the main with \verb!exit(EXIT_SUCCESS)!, and it would mean the same thing. On the other hand, if \verb!exit()! is used \textit{outside} of the main, the program will terminate once it reaches that statement, while a return statement would bring us back to the main. 

How do exit codes help us? After executing a program, we can type \verb!echo $?! to check the previous command's exit code. This can be used in shell programming, where we are telling the actual shell what to do. \\


In addition to exit codes and return values, there are a few important functions that are used to produce \vocab{error messages}: 

\begin{enumerate}
    \item The function \texttt{void perror(const char *str)} is used to describe the last error encountered during a library function or system call. If a string is provided, that string will be printed prior to the default error description. The default description is generated by a global variable called \verb!errno!, which comes from the \verb!errno.h! header file (i.e. it is an integer-to-string mapping).
    \item The \verb!char *strerror(int errnum)! function returns a pointer to the textual representation of the current errno value. 
\end{enumerate}

Note that neither of these functions kill the program. 


\subsection{Text and Binary Streams}

In C, most input and output is provided in the sequence of bytes, which is more commonly known as a \vocab{stream}. There are two types of streams: \vocab{text streams} and \vocab{binary streams}. 

\begin{itemize}
    \item Text streams consist of lines of text, each of which are terminated by the \verb!\n! character. They can be opened in text editors.
    \item Binary streams consist of raw data; they require a special editor to open. 
\end{itemize}

What are the advantages of one type of stream over another? When we're using text streams, we can easily debug the program (it's human-readable and doesn't require additional tools, while binary files do). On the other hand, text streams might not be a great idea for when we're modifying files a lot: changing even a single character requires re-reading the entire file. If we were using a binary stream, however, we could (in most cases) just change the relevant bytes.

\subsection{Standard Input/Output}

Now, we'll discuss how to read and write to files.


For files you want to read or write, we need a \vocab{file pointer}, declared like \verb!FILE *fp!. Realistically, it isn't really important what the type \verb!FILE! actually is -- we can just think of it as some abstract data structure which permits us to perform file I/O operations. 


Performing file I/O operations has three key steps: \begin{enumerate}
    \item Open the file
    \item Perform any processing
    \item Close the file
\end{enumerate}

To open the file, we use the \verb!fopen! command, whose declaration is as follows: \texttt{FILE *fopen(const char *filename, const char *mode)
}. Note that the function returns a file pointer, which we'll set our pointer equal to. If there's any error in opening the file, \verb!fopen! will return \verb!NULL!. 

The \verb!filename! parameter is a string, which holds the name of the file on the disk (including a path if necessary), and the \verb!mode! is another string, which represents \textit{how} we want to open the file. In this class, the file will be opened with mode equal to ``r" (for reading) or ``w" (for writing). Another mode is ``a", which lets us append to a file, without losing the rest of its contents.  


Once we've opened the file, we're ready for processing. If we're reading the file, we can use the \texttt{fgets()} function, whose declaration is specified as follows: \texttt{char *fgets(char *str, int n, FILE *stream)}. The parameter \verb!str! in \verb!fgets! stores the line read by the function, and it stops reading until either \verb!n! characters have been read, or a \verb!\n! character is encountered. Note that this \verb!\n! character is also stored as a part of the out parameter. If there are any errors, the function returns \verb!NULL!. 

If we're writing the file, we can use the \verb!fputs()! function, whose declaration is the following: \texttt{int fputs(const char *str, FILE *stream)}. It places the string \verb!str! into the file \verb!stream!. The function returns a non-negative integer upon success.


Finally, we need to close the file. This requires use of the  \verb!fclose()! function, whose declaration is as follows: \texttt{int fclose(FILE *stream)}. The function returns $0$ upon success, and it signals that we are done processing the file.


The three key steps of file I/O operations are captured with the following code segment:

\lstset{
caption=Processing a File
\label{Processing a Line}
}
\begin{center}
\lstinputlisting[language=c]{june17/june1701.c}
\end{center}

On Lines $9$ and $10$, the program prompts a file name, which is subsequently stored. Line $11$ attempts to open the file; upon success, each line is processed and printed. If the file cannot be opened, an error message is printed, and an exit code is returned. Line $18$ closes the input stream, and Line $19$ returns a successful exit code. Note that when we're printing on Line $16$, there's no \verb!\n! necessary. When we perform \verb!fgets()!, we've already stored the new-line character, so adding an additional \verb!\n! will put two spaces between lines. \\

If we want formatted input and output, we can similarly use \verb!fprintf()! and \verb!fscanf()!. 

Nelson says that, at this point, we should be able to write a C program that copies one file to another using command line arguments. \\

Every program has three defined streams: \vocab{standard input}, \vocab{standard output}, and \vocab{standard error}. We can use the the keyword \verb!stdin! in place of a file pointer to read from the user's keyboard.

Like standard input, standard error is also printed to the screen. It is denoted by the built-in file pointer \verb!sterr!, and it is helpful since it allows us to sort out our print statements, depending on whether a program executed successfully or not. 

So, standard input and standard error are different files; however, they both map to the screen. To direct standard error, we can use \verb!> &! in Unix. 


The end of a file is denoted by an invisible \vocab{end of file} (EOF) character. There's a function with the header \verb!int feof(FILE *fstream)! that checks whether the EOF file has been reached, after the file has been attempted to been open. We can manually enter the end-of-file character with our keyboard by entering \texttt{CTRL + D}. 


It is important to note that we need to first attempt to read the file before using \verb!feof()!. 


%streams_example.c for Project 3